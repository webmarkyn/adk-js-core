var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { createPartFromText } from "@google/genai";
import { trace } from "@opentelemetry/api";
import { InvocationContext, newInvocationContextId } from "../agents/invocation_context.js";
import { LlmAgent } from "../agents/llm_agent.js";
import { createRunConfig } from "../agents/run_config.js";
import { BuiltInCodeExecutor } from "../code_executors/built_in_code_executor.js";
import { createEvent, getFunctionCalls } from "../events/event.js";
import { createEventActions } from "../events/event_actions.js";
import { PluginManager } from "../plugins/plugin_manager.js";
import { logger } from "../utils/logger.js";
import { isGemini2OrAbove } from "../utils/model_name.js";
class Runner {
  constructor(input) {
    var _a;
    this.appName = input.appName;
    this.agent = input.agent;
    this.pluginManager = new PluginManager((_a = input.plugins) != null ? _a : []);
    this.artifactService = input.artifactService;
    this.sessionService = input.sessionService;
    this.memoryService = input.memoryService;
    this.credentialService = input.credentialService;
  }
  /**
   * Runs the agent with the given message, and returns an async generator of
   * events.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param newMessage A new message to append to the session.
   * @param stateDelta An optional state delta to apply to the session.
   * @param runConfig The run config for the agent.
   * @yields The events generated by the agent.
   */
  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.
  runAsync(_0) {
    return __asyncGenerator(this, arguments, function* ({
      userId,
      sessionId,
      newMessage,
      stateDelta,
      runConfig
    }) {
      var _a;
      runConfig = createRunConfig(runConfig);
      const span = trace.getTracer("gcp.vertex.agent").startSpan("invocation");
      try {
        const session = yield new __await(this.sessionService.getSession({ appName: this.appName, userId, sessionId }));
        if (!session) {
          if (!this.appName) {
            throw new Error(
              "Session lookup failed: appName must be provided in runner constructor"
            );
          }
          throw new Error("Session not found: ".concat(sessionId));
        }
        if (runConfig.supportCfc && this.agent instanceof LlmAgent) {
          const modelName = this.agent.canonicalModel.model;
          if (!isGemini2OrAbove(modelName)) {
            throw new Error("CFC is not supported for model: ".concat(modelName, " in agent: ").concat(this.agent.name));
          }
          if (!(this.agent.codeExecutor instanceof BuiltInCodeExecutor)) {
            this.agent.codeExecutor = new BuiltInCodeExecutor();
          }
        }
        const invocationContext = new InvocationContext({
          artifactService: this.artifactService,
          sessionService: this.sessionService,
          memoryService: this.memoryService,
          credentialService: this.credentialService,
          invocationId: newInvocationContextId(),
          agent: this.agent,
          session,
          userContent: newMessage,
          runConfig,
          pluginManager: this.pluginManager
        });
        const pluginUserMessage = yield new __await(this.pluginManager.runOnUserMessageCallback({
          userMessage: newMessage,
          invocationContext
        }));
        if (pluginUserMessage) {
          newMessage = pluginUserMessage;
        }
        if (newMessage) {
          if (!((_a = newMessage.parts) == null ? void 0 : _a.length)) {
            throw new Error("No parts in the newMessage.");
          }
          if (runConfig.saveInputBlobsAsArtifacts) {
            yield new __await(this.saveArtifacts(
              invocationContext.invocationId,
              session.userId,
              session.id,
              newMessage
            ));
          }
          yield new __await(this.sessionService.appendEvent({
            session,
            event: createEvent({
              invocationId: invocationContext.invocationId,
              author: "user",
              actions: stateDelta ? createEventActions({ stateDelta }) : void 0,
              content: newMessage
            })
          }));
        }
        invocationContext.agent = this.determineAgentForResumption(session, this.agent);
        const beforeRunCallbackResponse = yield new __await(this.pluginManager.runBeforeRunCallback({ invocationContext }));
        if (beforeRunCallbackResponse) {
          const earlyExitEvent = createEvent({
            invocationId: invocationContext.invocationId,
            author: "model",
            content: beforeRunCallbackResponse
          });
          yield new __await(this.sessionService.appendEvent({ session, event: earlyExitEvent }));
          yield earlyExitEvent;
        } else {
          try {
            for (var iter = __forAwait(invocationContext.agent.runAsync(
              invocationContext
            )), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
              const event = temp.value;
              if (!event.partial) {
                yield new __await(this.sessionService.appendEvent({ session, event }));
              }
              const modifiedEvent = yield new __await(this.pluginManager.runOnEventCallback(
                { invocationContext, event }
              ));
              if (modifiedEvent) {
                yield modifiedEvent;
              } else {
                yield event;
              }
            }
          } catch (temp) {
            error = [temp];
          } finally {
            try {
              more && (temp = iter.return) && (yield new __await(temp.call(iter)));
            } finally {
              if (error)
                throw error[0];
            }
          }
        }
        yield new __await(this.pluginManager.runAfterRunCallback({ invocationContext }));
      } finally {
        span.end();
      }
    });
  }
  /**
   * Saves artifacts from the message parts and replaces the inline data with
   * a file name placeholder.
   *
   * @param invocationId The current invocation ID.
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param message The message containing parts to process.
   */
  async saveArtifacts(invocationId, userId, sessionId, message) {
    var _a;
    if (!this.artifactService || !((_a = message.parts) == null ? void 0 : _a.length)) {
      return;
    }
    for (let i = 0; i < message.parts.length; i++) {
      const part = message.parts[i];
      if (!part.inlineData) {
        continue;
      }
      const fileName = "artifact_".concat(invocationId, "_").concat(i);
      await this.artifactService.saveArtifact({
        appName: this.appName,
        userId,
        sessionId,
        filename: fileName,
        artifact: part
      });
      message.parts[i] = createPartFromText(
        "Uploaded file: ".concat(fileName, ". It is saved into artifacts")
      );
    }
  }
  /**
   * Determines the next agent to run to continue the session. This is primarily
   * used for session resumption.
   */
  // TODO - b/425992518: This is where LRO integration should happen.
  // Needs clean up before we can generalize it.
  determineAgentForResumption(session, rootAgent) {
    const event = findEventByLastFunctionResponseId(session.events);
    if (event && event.author) {
      return rootAgent.findAgent(event.author) || rootAgent;
    }
    for (let i = session.events.length - 1; i >= 0; i--) {
      logger.info("event: ", JSON.stringify(session.events[i]));
      const event2 = session.events[i];
      if (event2.author === "user" || !event2.author) {
        continue;
      }
      if (event2.author === rootAgent.name) {
        return rootAgent;
      }
      const agent = rootAgent.findSubAgent(event2.author);
      if (!agent) {
        logger.warn("Event from an unknown agent: ".concat(event2.author, ", event id: ").concat(event2.id));
        continue;
      }
      if (this.isRoutableLlmAgent(agent)) {
        return agent;
      }
    }
    return rootAgent;
  }
  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * An agent is transferable if:
   *  - It is an instance of `LlmAgent`.
   *  - All its ancestors are also transferable (i.e., they have
   *    `disallowTransferToParent` set to false).
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   */
  isRoutableLlmAgent(agentToRun) {
    let agent = agentToRun;
    while (agent) {
      if (!(agent instanceof LlmAgent)) {
        return false;
      }
      if (agent.disallowTransferToParent) {
        return false;
      }
      agent = agent.parentAgent;
    }
    return true;
  }
  // TODO - b/425992518: Implement runLive and related methods.
}
function findEventByLastFunctionResponseId(events) {
  var _a, _b, _c, _d;
  if (!events.length) {
    return null;
  }
  const lastEvent = events[events.length - 1];
  const functionCallId = (_d = (_c = (_b = (_a = lastEvent.content) == null ? void 0 : _a.parts) == null ? void 0 : _b.find((part) => part.functionResponse)) == null ? void 0 : _c.functionResponse) == null ? void 0 : _d.id;
  if (!functionCallId) {
    return null;
  }
  for (let i = events.length - 2; i >= 0; i--) {
    const event = events[i];
    const functionCalls = getFunctionCalls(event);
    if (!functionCalls) {
      continue;
    }
    for (const functionCall of functionCalls) {
      if (functionCall.id === functionCallId) {
        return event;
      }
    }
  }
  return null;
}
export {
  Runner
};
