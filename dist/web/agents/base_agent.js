var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __asyncGenerator = (__this, __arguments, generator) => {
  var resume = (k, v, yes, no) => {
    try {
      var x = generator[k](v), isAwait = (v = x.value) instanceof __await, done = x.done;
      Promise.resolve(isAwait ? v[0] : v).then((y) => isAwait ? resume(k === "return" ? k : "next", v[1] ? { done: y.done, value: y.value } : y, yes, no) : yes({ value: y, done })).catch((e) => resume("throw", e, yes, no));
    } catch (e) {
      no(e);
    }
  }, method = (k) => it[k] = (x) => new Promise((yes, no) => resume(k, x, yes, no)), it = {};
  return generator = generator.apply(__this, __arguments), it[__knownSymbol("asyncIterator")] = () => it, method("next"), method("throw"), method("return"), it;
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
import { trace } from "@opentelemetry/api";
import { createEvent } from "../events/event.js";
import { CallbackContext } from "./callback_context.js";
import { InvocationContext } from "./invocation_context.js";
const BASE_AGENT_SIGNATURE_SYMBOL = Symbol.for("google.adk.baseAgent");
function isBaseAgent(obj) {
  return typeof obj === "object" && obj !== null && BASE_AGENT_SIGNATURE_SYMBOL in obj && obj[BASE_AGENT_SIGNATURE_SYMBOL] === true;
}
_a = BASE_AGENT_SIGNATURE_SYMBOL;
class BaseAgent {
  constructor(config) {
    /**
     * A unique symbol to identify ADK agent classes.
     */
    this[_a] = true;
    this.name = validateAgentName(config.name);
    this.description = config.description;
    this.parentAgent = config.parentAgent;
    this.subAgents = config.subAgents || [];
    this.rootAgent = getRootAgent(this);
    this.beforeAgentCallback = getCannonicalCallback(config.beforeAgentCallback);
    this.afterAgentCallback = getCannonicalCallback(config.afterAgentCallback);
    this.setParentAgentForSubAgents();
  }
  /**
   * Entry method to run an agent via text-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  runAsync(parentContext) {
    return __asyncGenerator(this, null, function* () {
      const span = trace.getTracer("gcp.vertex.agent").startSpan("agent_run [".concat(this.name, "]"));
      try {
        const context = this.createInvocationContext(parentContext);
        const beforeAgentCallbackEvent = yield new __await(this.handleBeforeAgentCallback(context));
        if (beforeAgentCallbackEvent) {
          yield beforeAgentCallbackEvent;
        }
        if (context.endInvocation) {
          return;
        }
        try {
          for (var iter = __forAwait(this.runAsyncImpl(context)), more, temp, error; more = !(temp = yield new __await(iter.next())).done; more = false) {
            const event = temp.value;
            yield event;
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield new __await(temp.call(iter)));
          } finally {
            if (error)
              throw error[0];
          }
        }
        if (context.endInvocation) {
          return;
        }
        const afterAgentCallbackEvent = yield new __await(this.handleAfterAgentCallback(context));
        if (afterAgentCallbackEvent) {
          yield afterAgentCallbackEvent;
        }
      } finally {
        span.end();
      }
    });
  }
  /**
   * Entry method to run an agent via video/audio-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  runLive(parentContext) {
    return __asyncGenerator(this, null, function* () {
      const span = trace.getTracer("gcp.vertex.agent").startSpan("agent_run [".concat(this.name, "]"));
      try {
        throw new Error("Live mode is not implemented yet.");
      } finally {
        span.end();
      }
    });
  }
  /**
   * Finds the agent with the given name in this agent and its descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findAgent(name) {
    if (this.name === name) {
      return this;
    }
    return this.findSubAgent(name);
  }
  /**
   * Finds the agent with the given name in this agent's descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findSubAgent(name) {
    for (const subAgent of this.subAgents) {
      const result = subAgent.findAgent(name);
      if (result) {
        return result;
      }
    }
    return void 0;
  }
  /**
   * Creates an invocation context for this agent.
   *
   * @param parentContext The invocation context of the parent agent.
   * @return The invocation context for this agent.
   */
  createInvocationContext(parentContext) {
    return new InvocationContext(__spreadProps(__spreadValues({}, parentContext), {
      agent: this
    }));
  }
  /**
   * Runs the before agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  async handleBeforeAgentCallback(invocationContext) {
    if (this.beforeAgentCallback.length === 0) {
      return void 0;
    }
    const callbackContext = new CallbackContext({ invocationContext });
    for (const callback of this.beforeAgentCallback) {
      const content = await callback(callbackContext);
      if (content) {
        invocationContext.endInvocation = true;
        return createEvent({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions
        });
      }
    }
    if (callbackContext.state.hasDelta()) {
      return createEvent({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions
      });
    }
    return void 0;
  }
  /**
   * Runs the after agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  async handleAfterAgentCallback(invocationContext) {
    if (this.afterAgentCallback.length === 0) {
      return void 0;
    }
    const callbackContext = new CallbackContext({ invocationContext });
    for (const callback of this.afterAgentCallback) {
      const content = await callback(callbackContext);
      if (content) {
        return createEvent({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions
        });
      }
    }
    if (callbackContext.state.hasDelta()) {
      return createEvent({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions
      });
    }
    return void 0;
  }
  setParentAgentForSubAgents() {
    for (const subAgent of this.subAgents) {
      if (subAgent.parentAgent) {
        throw new Error('Agent "'.concat(subAgent.name, '" already has a parent agent, current parent: "').concat(subAgent.parentAgent.name, '", trying to add: "').concat(this.name, '"'));
      }
      subAgent.parentAgent = this;
    }
  }
}
function validateAgentName(name) {
  if (!isIdentifier(name)) {
    throw new Error('Found invalid agent name: "'.concat(name, '". Agent name must be a valid identifier. It should start with a letter (a-z, A-Z) or an underscore (_), and can only contain letters, digits (0-9), and underscores.'));
  }
  if (name === "user") {
    throw new Error(
      "Agent name cannot be 'user'. 'user' is reserved for end-user's input."
    );
  }
  return name;
}
function isIdentifier(str) {
  return new RegExp("^[\\p{ID_Start}$_][\\p{ID_Continue}$_]*$", "u").test(str);
}
function getRootAgent(rootAgent) {
  while (rootAgent.parentAgent) {
    rootAgent = rootAgent.parentAgent;
  }
  return rootAgent;
}
function getCannonicalCallback(callbacks) {
  if (!callbacks) {
    return [];
  }
  return Array.isArray(callbacks) ? callbacks : [callbacks];
}
export {
  BaseAgent,
  getCannonicalCallback,
  isBaseAgent
};
