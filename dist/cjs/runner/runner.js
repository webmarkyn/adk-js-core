/**
  * @license
  * Copyright 2025 Google LLC
  * SPDX-License-Identifier: Apache-2.0
  */

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var runner_exports = {};
__export(runner_exports, {
  Runner: () => Runner
});
module.exports = __toCommonJS(runner_exports);
var import_genai = require("@google/genai");
var import_api = require("@opentelemetry/api");
var import_invocation_context = require("../agents/invocation_context.js");
var import_llm_agent = require("../agents/llm_agent.js");
var import_run_config = require("../agents/run_config.js");
var import_built_in_code_executor = require("../code_executors/built_in_code_executor.js");
var import_event = require("../events/event.js");
var import_event_actions = require("../events/event_actions.js");
var import_plugin_manager = require("../plugins/plugin_manager.js");
var import_logger = require("../utils/logger.js");
var import_model_name = require("../utils/model_name.js");
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Runner {
  constructor(input) {
    var _a;
    this.appName = input.appName;
    this.agent = input.agent;
    this.pluginManager = new import_plugin_manager.PluginManager((_a = input.plugins) != null ? _a : []);
    this.artifactService = input.artifactService;
    this.sessionService = input.sessionService;
    this.memoryService = input.memoryService;
    this.credentialService = input.credentialService;
  }
  /**
   * Runs the agent with the given message, and returns an async generator of
   * events.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param newMessage A new message to append to the session.
   * @param stateDelta An optional state delta to apply to the session.
   * @param runConfig The run config for the agent.
   * @yields The events generated by the agent.
   */
  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.
  async *runAsync({
    userId,
    sessionId,
    newMessage,
    stateDelta,
    runConfig
  }) {
    var _a;
    runConfig = (0, import_run_config.createRunConfig)(runConfig);
    const span = import_api.trace.getTracer("gcp.vertex.agent").startSpan("invocation");
    try {
      const session = await this.sessionService.getSession({ appName: this.appName, userId, sessionId });
      if (!session) {
        if (!this.appName) {
          throw new Error(
            `Session lookup failed: appName must be provided in runner constructor`
          );
        }
        throw new Error(`Session not found: ${sessionId}`);
      }
      if (runConfig.supportCfc && this.agent instanceof import_llm_agent.LlmAgent) {
        const modelName = this.agent.canonicalModel.model;
        if (!(0, import_model_name.isGemini2OrAbove)(modelName)) {
          throw new Error(`CFC is not supported for model: ${modelName} in agent: ${this.agent.name}`);
        }
        if (!(this.agent.codeExecutor instanceof import_built_in_code_executor.BuiltInCodeExecutor)) {
          this.agent.codeExecutor = new import_built_in_code_executor.BuiltInCodeExecutor();
        }
      }
      const invocationContext = new import_invocation_context.InvocationContext({
        artifactService: this.artifactService,
        sessionService: this.sessionService,
        memoryService: this.memoryService,
        credentialService: this.credentialService,
        invocationId: (0, import_invocation_context.newInvocationContextId)(),
        agent: this.agent,
        session,
        userContent: newMessage,
        runConfig,
        pluginManager: this.pluginManager
      });
      const pluginUserMessage = await this.pluginManager.runOnUserMessageCallback({
        userMessage: newMessage,
        invocationContext
      });
      if (pluginUserMessage) {
        newMessage = pluginUserMessage;
      }
      if (newMessage) {
        if (!((_a = newMessage.parts) == null ? void 0 : _a.length)) {
          throw new Error("No parts in the newMessage.");
        }
        if (runConfig.saveInputBlobsAsArtifacts) {
          await this.saveArtifacts(
            invocationContext.invocationId,
            session.userId,
            session.id,
            newMessage
          );
        }
        await this.sessionService.appendEvent({
          session,
          event: (0, import_event.createEvent)({
            invocationId: invocationContext.invocationId,
            author: "user",
            actions: stateDelta ? (0, import_event_actions.createEventActions)({ stateDelta }) : void 0,
            content: newMessage
          })
        });
      }
      invocationContext.agent = this.determineAgentForResumption(session, this.agent);
      const beforeRunCallbackResponse = await this.pluginManager.runBeforeRunCallback({ invocationContext });
      if (beforeRunCallbackResponse) {
        const earlyExitEvent = (0, import_event.createEvent)({
          invocationId: invocationContext.invocationId,
          author: "model",
          content: beforeRunCallbackResponse
        });
        await this.sessionService.appendEvent({ session, event: earlyExitEvent });
        yield earlyExitEvent;
      } else {
        for await (const event of invocationContext.agent.runAsync(
          invocationContext
        )) {
          if (!event.partial) {
            await this.sessionService.appendEvent({ session, event });
          }
          const modifiedEvent = await this.pluginManager.runOnEventCallback(
            { invocationContext, event }
          );
          if (modifiedEvent) {
            yield modifiedEvent;
          } else {
            yield event;
          }
        }
      }
      await this.pluginManager.runAfterRunCallback({ invocationContext });
    } finally {
      span.end();
    }
  }
  /**
   * Saves artifacts from the message parts and replaces the inline data with
   * a file name placeholder.
   *
   * @param invocationId The current invocation ID.
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param message The message containing parts to process.
   */
  async saveArtifacts(invocationId, userId, sessionId, message) {
    var _a;
    if (!this.artifactService || !((_a = message.parts) == null ? void 0 : _a.length)) {
      return;
    }
    for (let i = 0; i < message.parts.length; i++) {
      const part = message.parts[i];
      if (!part.inlineData) {
        continue;
      }
      const fileName = `artifact_${invocationId}_${i}`;
      await this.artifactService.saveArtifact({
        appName: this.appName,
        userId,
        sessionId,
        filename: fileName,
        artifact: part
      });
      message.parts[i] = (0, import_genai.createPartFromText)(
        `Uploaded file: ${fileName}. It is saved into artifacts`
      );
    }
  }
  /**
   * Determines the next agent to run to continue the session. This is primarily
   * used for session resumption.
   */
  // TODO - b/425992518: This is where LRO integration should happen.
  // Needs clean up before we can generalize it.
  determineAgentForResumption(session, rootAgent) {
    const event = findEventByLastFunctionResponseId(session.events);
    if (event && event.author) {
      return rootAgent.findAgent(event.author) || rootAgent;
    }
    for (let i = session.events.length - 1; i >= 0; i--) {
      import_logger.logger.info("event: ", JSON.stringify(session.events[i]));
      const event2 = session.events[i];
      if (event2.author === "user" || !event2.author) {
        continue;
      }
      if (event2.author === rootAgent.name) {
        return rootAgent;
      }
      const agent = rootAgent.findSubAgent(event2.author);
      if (!agent) {
        import_logger.logger.warn(`Event from an unknown agent: ${event2.author}, event id: ${event2.id}`);
        continue;
      }
      if (this.isRoutableLlmAgent(agent)) {
        return agent;
      }
    }
    return rootAgent;
  }
  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * An agent is transferable if:
   *  - It is an instance of `LlmAgent`.
   *  - All its ancestors are also transferable (i.e., they have
   *    `disallowTransferToParent` set to false).
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   */
  isRoutableLlmAgent(agentToRun) {
    let agent = agentToRun;
    while (agent) {
      if (!(agent instanceof import_llm_agent.LlmAgent)) {
        return false;
      }
      if (agent.disallowTransferToParent) {
        return false;
      }
      agent = agent.parentAgent;
    }
    return true;
  }
  // TODO - b/425992518: Implement runLive and related methods.
}
function findEventByLastFunctionResponseId(events) {
  var _a, _b, _c, _d;
  if (!events.length) {
    return null;
  }
  const lastEvent = events[events.length - 1];
  const functionCallId = (_d = (_c = (_b = (_a = lastEvent.content) == null ? void 0 : _a.parts) == null ? void 0 : _b.find((part) => part.functionResponse)) == null ? void 0 : _c.functionResponse) == null ? void 0 : _d.id;
  if (!functionCallId) {
    return null;
  }
  for (let i = events.length - 2; i >= 0; i--) {
    const event = events[i];
    const functionCalls = (0, import_event.getFunctionCalls)(event);
    if (!functionCalls) {
      continue;
    }
    for (const functionCall of functionCalls) {
      if (functionCall.id === functionCallId) {
        return event;
      }
    }
  }
  return null;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Runner
});
