/**
  * @license
  * Copyright 2025 Google LLC
  * SPDX-License-Identifier: Apache-2.0
  */

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var base_agent_exports = {};
__export(base_agent_exports, {
  BaseAgent: () => BaseAgent,
  getCannonicalCallback: () => getCannonicalCallback,
  isBaseAgent: () => isBaseAgent
});
module.exports = __toCommonJS(base_agent_exports);
var import_api = require("@opentelemetry/api");
var import_event = require("../events/event.js");
var import_callback_context = require("./callback_context.js");
var import_invocation_context = require("./invocation_context.js");
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
const BASE_AGENT_SIGNATURE_SYMBOL = Symbol.for("google.adk.baseAgent");
function isBaseAgent(obj) {
  return typeof obj === "object" && obj !== null && BASE_AGENT_SIGNATURE_SYMBOL in obj && obj[BASE_AGENT_SIGNATURE_SYMBOL] === true;
}
_a = BASE_AGENT_SIGNATURE_SYMBOL;
class BaseAgent {
  constructor(config) {
    /**
     * A unique symbol to identify ADK agent classes.
     */
    this[_a] = true;
    this.name = validateAgentName(config.name);
    this.description = config.description;
    this.parentAgent = config.parentAgent;
    this.subAgents = config.subAgents || [];
    this.rootAgent = getRootAgent(this);
    this.beforeAgentCallback = getCannonicalCallback(config.beforeAgentCallback);
    this.afterAgentCallback = getCannonicalCallback(config.afterAgentCallback);
    this.setParentAgentForSubAgents();
  }
  /**
   * Entry method to run an agent via text-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  async *runAsync(parentContext) {
    const span = import_api.trace.getTracer("gcp.vertex.agent").startSpan(`agent_run [${this.name}]`);
    try {
      const context = this.createInvocationContext(parentContext);
      const beforeAgentCallbackEvent = await this.handleBeforeAgentCallback(context);
      if (beforeAgentCallbackEvent) {
        yield beforeAgentCallbackEvent;
      }
      if (context.endInvocation) {
        return;
      }
      for await (const event of this.runAsyncImpl(context)) {
        yield event;
      }
      if (context.endInvocation) {
        return;
      }
      const afterAgentCallbackEvent = await this.handleAfterAgentCallback(context);
      if (afterAgentCallbackEvent) {
        yield afterAgentCallbackEvent;
      }
    } finally {
      span.end();
    }
  }
  /**
   * Entry method to run an agent via video/audio-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  async *runLive(parentContext) {
    const span = import_api.trace.getTracer("gcp.vertex.agent").startSpan(`agent_run [${this.name}]`);
    try {
      throw new Error("Live mode is not implemented yet.");
    } finally {
      span.end();
    }
  }
  /**
   * Finds the agent with the given name in this agent and its descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findAgent(name) {
    if (this.name === name) {
      return this;
    }
    return this.findSubAgent(name);
  }
  /**
   * Finds the agent with the given name in this agent's descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findSubAgent(name) {
    for (const subAgent of this.subAgents) {
      const result = subAgent.findAgent(name);
      if (result) {
        return result;
      }
    }
    return void 0;
  }
  /**
   * Creates an invocation context for this agent.
   *
   * @param parentContext The invocation context of the parent agent.
   * @return The invocation context for this agent.
   */
  createInvocationContext(parentContext) {
    return new import_invocation_context.InvocationContext({
      ...parentContext,
      agent: this
    });
  }
  /**
   * Runs the before agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  async handleBeforeAgentCallback(invocationContext) {
    if (this.beforeAgentCallback.length === 0) {
      return void 0;
    }
    const callbackContext = new import_callback_context.CallbackContext({ invocationContext });
    for (const callback of this.beforeAgentCallback) {
      const content = await callback(callbackContext);
      if (content) {
        invocationContext.endInvocation = true;
        return (0, import_event.createEvent)({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions
        });
      }
    }
    if (callbackContext.state.hasDelta()) {
      return (0, import_event.createEvent)({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions
      });
    }
    return void 0;
  }
  /**
   * Runs the after agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  async handleAfterAgentCallback(invocationContext) {
    if (this.afterAgentCallback.length === 0) {
      return void 0;
    }
    const callbackContext = new import_callback_context.CallbackContext({ invocationContext });
    for (const callback of this.afterAgentCallback) {
      const content = await callback(callbackContext);
      if (content) {
        return (0, import_event.createEvent)({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions
        });
      }
    }
    if (callbackContext.state.hasDelta()) {
      return (0, import_event.createEvent)({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions
      });
    }
    return void 0;
  }
  setParentAgentForSubAgents() {
    for (const subAgent of this.subAgents) {
      if (subAgent.parentAgent) {
        throw new Error(`Agent "${subAgent.name}" already has a parent agent, current parent: "${subAgent.parentAgent.name}", trying to add: "${this.name}"`);
      }
      subAgent.parentAgent = this;
    }
  }
}
function validateAgentName(name) {
  if (!isIdentifier(name)) {
    throw new Error(`Found invalid agent name: "${name}". Agent name must be a valid identifier. It should start with a letter (a-z, A-Z) or an underscore (_), and can only contain letters, digits (0-9), and underscores.`);
  }
  if (name === "user") {
    throw new Error(
      `Agent name cannot be 'user'. 'user' is reserved for end-user's input.`
    );
  }
  return name;
}
function isIdentifier(str) {
  return /^[\p{ID_Start}$_][\p{ID_Continue}$_]*$/u.test(str);
}
function getRootAgent(rootAgent) {
  while (rootAgent.parentAgent) {
    rootAgent = rootAgent.parentAgent;
  }
  return rootAgent;
}
function getCannonicalCallback(callbacks) {
  if (!callbacks) {
    return [];
  }
  return Array.isArray(callbacks) ? callbacks : [callbacks];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseAgent,
  getCannonicalCallback,
  isBaseAgent
});
