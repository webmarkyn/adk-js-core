/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a;
import { trace } from "@opentelemetry/api";
import { createEvent } from "../events/event.js";
import { CallbackContext } from "./callback_context.js";
import { InvocationContext } from "./invocation_context.js";
const BASE_AGENT_SIGNATURE_SYMBOL = Symbol.for("google.adk.baseAgent");
function isBaseAgent(obj) {
  return typeof obj === "object" && obj !== null && BASE_AGENT_SIGNATURE_SYMBOL in obj && obj[BASE_AGENT_SIGNATURE_SYMBOL] === true;
}
_a = BASE_AGENT_SIGNATURE_SYMBOL;
class BaseAgent {
  constructor(config) {
    /**
     * A unique symbol to identify ADK agent classes.
     */
    this[_a] = true;
    this.name = validateAgentName(config.name);
    this.description = config.description;
    this.parentAgent = config.parentAgent;
    this.subAgents = config.subAgents || [];
    this.rootAgent = getRootAgent(this);
    this.beforeAgentCallback = getCannonicalCallback(config.beforeAgentCallback);
    this.afterAgentCallback = getCannonicalCallback(config.afterAgentCallback);
    this.setParentAgentForSubAgents();
  }
  /**
   * Entry method to run an agent via text-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  async *runAsync(parentContext) {
    const span = trace.getTracer("gcp.vertex.agent").startSpan(`agent_run [${this.name}]`);
    try {
      const context = this.createInvocationContext(parentContext);
      const beforeAgentCallbackEvent = await this.handleBeforeAgentCallback(context);
      if (beforeAgentCallbackEvent) {
        yield beforeAgentCallbackEvent;
      }
      if (context.endInvocation) {
        return;
      }
      for await (const event of this.runAsyncImpl(context)) {
        yield event;
      }
      if (context.endInvocation) {
        return;
      }
      const afterAgentCallbackEvent = await this.handleAfterAgentCallback(context);
      if (afterAgentCallbackEvent) {
        yield afterAgentCallbackEvent;
      }
    } finally {
      span.end();
    }
  }
  /**
   * Entry method to run an agent via video/audio-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  async *runLive(parentContext) {
    const span = trace.getTracer("gcp.vertex.agent").startSpan(`agent_run [${this.name}]`);
    try {
      throw new Error("Live mode is not implemented yet.");
    } finally {
      span.end();
    }
  }
  /**
   * Finds the agent with the given name in this agent and its descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findAgent(name) {
    if (this.name === name) {
      return this;
    }
    return this.findSubAgent(name);
  }
  /**
   * Finds the agent with the given name in this agent's descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findSubAgent(name) {
    for (const subAgent of this.subAgents) {
      const result = subAgent.findAgent(name);
      if (result) {
        return result;
      }
    }
    return void 0;
  }
  /**
   * Creates an invocation context for this agent.
   *
   * @param parentContext The invocation context of the parent agent.
   * @return The invocation context for this agent.
   */
  createInvocationContext(parentContext) {
    return new InvocationContext({
      ...parentContext,
      agent: this
    });
  }
  /**
   * Runs the before agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  async handleBeforeAgentCallback(invocationContext) {
    if (this.beforeAgentCallback.length === 0) {
      return void 0;
    }
    const callbackContext = new CallbackContext({ invocationContext });
    for (const callback of this.beforeAgentCallback) {
      const content = await callback(callbackContext);
      if (content) {
        invocationContext.endInvocation = true;
        return createEvent({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions
        });
      }
    }
    if (callbackContext.state.hasDelta()) {
      return createEvent({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions
      });
    }
    return void 0;
  }
  /**
   * Runs the after agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  async handleAfterAgentCallback(invocationContext) {
    if (this.afterAgentCallback.length === 0) {
      return void 0;
    }
    const callbackContext = new CallbackContext({ invocationContext });
    for (const callback of this.afterAgentCallback) {
      const content = await callback(callbackContext);
      if (content) {
        return createEvent({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions
        });
      }
    }
    if (callbackContext.state.hasDelta()) {
      return createEvent({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions
      });
    }
    return void 0;
  }
  setParentAgentForSubAgents() {
    for (const subAgent of this.subAgents) {
      if (subAgent.parentAgent) {
        throw new Error(`Agent "${subAgent.name}" already has a parent agent, current parent: "${subAgent.parentAgent.name}", trying to add: "${this.name}"`);
      }
      subAgent.parentAgent = this;
    }
  }
}
function validateAgentName(name) {
  if (!isIdentifier(name)) {
    throw new Error(`Found invalid agent name: "${name}". Agent name must be a valid identifier. It should start with a letter (a-z, A-Z) or an underscore (_), and can only contain letters, digits (0-9), and underscores.`);
  }
  if (name === "user") {
    throw new Error(
      `Agent name cannot be 'user'. 'user' is reserved for end-user's input.`
    );
  }
  return name;
}
function isIdentifier(str) {
  return /^[\p{ID_Start}$_][\p{ID_Continue}$_]*$/u.test(str);
}
function getRootAgent(rootAgent) {
  while (rootAgent.parentAgent) {
    rootAgent = rootAgent.parentAgent;
  }
  return rootAgent;
}
function getCannonicalCallback(callbacks) {
  if (!callbacks) {
    return [];
  }
  return Array.isArray(callbacks) ? callbacks : [callbacks];
}
export {
  BaseAgent,
  getCannonicalCallback,
  isBaseAgent
};
