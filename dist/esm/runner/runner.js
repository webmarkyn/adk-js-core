/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { createPartFromText } from "@google/genai";
import { trace } from "@opentelemetry/api";
import { InvocationContext, newInvocationContextId } from "../agents/invocation_context.js";
import { LlmAgent } from "../agents/llm_agent.js";
import { createRunConfig } from "../agents/run_config.js";
import { BuiltInCodeExecutor } from "../code_executors/built_in_code_executor.js";
import { createEvent, getFunctionCalls } from "../events/event.js";
import { createEventActions } from "../events/event_actions.js";
import { PluginManager } from "../plugins/plugin_manager.js";
import { logger } from "../utils/logger.js";
import { isGemini2OrAbove } from "../utils/model_name.js";
class Runner {
  constructor(input) {
    var _a;
    this.appName = input.appName;
    this.agent = input.agent;
    this.pluginManager = new PluginManager((_a = input.plugins) != null ? _a : []);
    this.artifactService = input.artifactService;
    this.sessionService = input.sessionService;
    this.memoryService = input.memoryService;
    this.credentialService = input.credentialService;
  }
  /**
   * Runs the agent with the given message, and returns an async generator of
   * events.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param newMessage A new message to append to the session.
   * @param stateDelta An optional state delta to apply to the session.
   * @param runConfig The run config for the agent.
   * @yields The events generated by the agent.
   */
  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.
  async *runAsync({
    userId,
    sessionId,
    newMessage,
    stateDelta,
    runConfig
  }) {
    var _a;
    runConfig = createRunConfig(runConfig);
    const span = trace.getTracer("gcp.vertex.agent").startSpan("invocation");
    try {
      const session = await this.sessionService.getSession({ appName: this.appName, userId, sessionId });
      if (!session) {
        if (!this.appName) {
          throw new Error(
            `Session lookup failed: appName must be provided in runner constructor`
          );
        }
        throw new Error(`Session not found: ${sessionId}`);
      }
      if (runConfig.supportCfc && this.agent instanceof LlmAgent) {
        const modelName = this.agent.canonicalModel.model;
        if (!isGemini2OrAbove(modelName)) {
          throw new Error(`CFC is not supported for model: ${modelName} in agent: ${this.agent.name}`);
        }
        if (!(this.agent.codeExecutor instanceof BuiltInCodeExecutor)) {
          this.agent.codeExecutor = new BuiltInCodeExecutor();
        }
      }
      const invocationContext = new InvocationContext({
        artifactService: this.artifactService,
        sessionService: this.sessionService,
        memoryService: this.memoryService,
        credentialService: this.credentialService,
        invocationId: newInvocationContextId(),
        agent: this.agent,
        session,
        userContent: newMessage,
        runConfig,
        pluginManager: this.pluginManager
      });
      const pluginUserMessage = await this.pluginManager.runOnUserMessageCallback({
        userMessage: newMessage,
        invocationContext
      });
      if (pluginUserMessage) {
        newMessage = pluginUserMessage;
      }
      if (newMessage) {
        if (!((_a = newMessage.parts) == null ? void 0 : _a.length)) {
          throw new Error("No parts in the newMessage.");
        }
        if (runConfig.saveInputBlobsAsArtifacts) {
          await this.saveArtifacts(
            invocationContext.invocationId,
            session.userId,
            session.id,
            newMessage
          );
        }
        await this.sessionService.appendEvent({
          session,
          event: createEvent({
            invocationId: invocationContext.invocationId,
            author: "user",
            actions: stateDelta ? createEventActions({ stateDelta }) : void 0,
            content: newMessage
          })
        });
      }
      invocationContext.agent = this.determineAgentForResumption(session, this.agent);
      const beforeRunCallbackResponse = await this.pluginManager.runBeforeRunCallback({ invocationContext });
      if (beforeRunCallbackResponse) {
        const earlyExitEvent = createEvent({
          invocationId: invocationContext.invocationId,
          author: "model",
          content: beforeRunCallbackResponse
        });
        await this.sessionService.appendEvent({ session, event: earlyExitEvent });
        yield earlyExitEvent;
      } else {
        for await (const event of invocationContext.agent.runAsync(
          invocationContext
        )) {
          if (!event.partial) {
            await this.sessionService.appendEvent({ session, event });
          }
          const modifiedEvent = await this.pluginManager.runOnEventCallback(
            { invocationContext, event }
          );
          if (modifiedEvent) {
            yield modifiedEvent;
          } else {
            yield event;
          }
        }
      }
      await this.pluginManager.runAfterRunCallback({ invocationContext });
    } finally {
      span.end();
    }
  }
  /**
   * Saves artifacts from the message parts and replaces the inline data with
   * a file name placeholder.
   *
   * @param invocationId The current invocation ID.
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param message The message containing parts to process.
   */
  async saveArtifacts(invocationId, userId, sessionId, message) {
    var _a;
    if (!this.artifactService || !((_a = message.parts) == null ? void 0 : _a.length)) {
      return;
    }
    for (let i = 0; i < message.parts.length; i++) {
      const part = message.parts[i];
      if (!part.inlineData) {
        continue;
      }
      const fileName = `artifact_${invocationId}_${i}`;
      await this.artifactService.saveArtifact({
        appName: this.appName,
        userId,
        sessionId,
        filename: fileName,
        artifact: part
      });
      message.parts[i] = createPartFromText(
        `Uploaded file: ${fileName}. It is saved into artifacts`
      );
    }
  }
  /**
   * Determines the next agent to run to continue the session. This is primarily
   * used for session resumption.
   */
  // TODO - b/425992518: This is where LRO integration should happen.
  // Needs clean up before we can generalize it.
  determineAgentForResumption(session, rootAgent) {
    const event = findEventByLastFunctionResponseId(session.events);
    if (event && event.author) {
      return rootAgent.findAgent(event.author) || rootAgent;
    }
    for (let i = session.events.length - 1; i >= 0; i--) {
      logger.info("event: ", JSON.stringify(session.events[i]));
      const event2 = session.events[i];
      if (event2.author === "user" || !event2.author) {
        continue;
      }
      if (event2.author === rootAgent.name) {
        return rootAgent;
      }
      const agent = rootAgent.findSubAgent(event2.author);
      if (!agent) {
        logger.warn(`Event from an unknown agent: ${event2.author}, event id: ${event2.id}`);
        continue;
      }
      if (this.isRoutableLlmAgent(agent)) {
        return agent;
      }
    }
    return rootAgent;
  }
  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * An agent is transferable if:
   *  - It is an instance of `LlmAgent`.
   *  - All its ancestors are also transferable (i.e., they have
   *    `disallowTransferToParent` set to false).
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   */
  isRoutableLlmAgent(agentToRun) {
    let agent = agentToRun;
    while (agent) {
      if (!(agent instanceof LlmAgent)) {
        return false;
      }
      if (agent.disallowTransferToParent) {
        return false;
      }
      agent = agent.parentAgent;
    }
    return true;
  }
  // TODO - b/425992518: Implement runLive and related methods.
}
function findEventByLastFunctionResponseId(events) {
  var _a, _b, _c, _d;
  if (!events.length) {
    return null;
  }
  const lastEvent = events[events.length - 1];
  const functionCallId = (_d = (_c = (_b = (_a = lastEvent.content) == null ? void 0 : _a.parts) == null ? void 0 : _b.find((part) => part.functionResponse)) == null ? void 0 : _c.functionResponse) == null ? void 0 : _d.id;
  if (!functionCallId) {
    return null;
  }
  for (let i = events.length - 2; i >= 0; i--) {
    const event = events[i];
    const functionCalls = getFunctionCalls(event);
    if (!functionCalls) {
      continue;
    }
    for (const functionCall of functionCalls) {
      if (functionCall.id === functionCallId) {
        return event;
      }
    }
  }
  return null;
}
export {
  Runner
};
