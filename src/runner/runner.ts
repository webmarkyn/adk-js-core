/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Content, createPartFromText} from '@google/genai';
import {trace} from '@opentelemetry/api';

import {BaseAgent} from '../agents/base_agent.js';
import {InvocationContext, newInvocationContextId} from '../agents/invocation_context.js';
import {LlmAgent} from '../agents/llm_agent.js';
import {RunConfig} from '../agents/run_config.js';
import {BaseArtifactService} from '../artifacts/base_artifact_service.js';
import {BaseCredentialService} from '../auth/credential_service/base_credential_service.js';
import {createEvent, Event, getFunctionCalls} from '../events/event.js';
import {createEventActions, EventActions} from '../events/event_actions.js';
import {BaseMemoryService} from '../memory/base_memory_service.js';
import {BasePlugin} from '../plugins/base_plugin.js';
import {PluginManager} from '../plugins/plugin_manager.js';
import {BaseSessionService} from '../sessions/base_session_service.js';
import {Session} from '../sessions/session.js';

// TODO - b/425992518: Implement BuiltInCodeExecutor


interface RunnerInput {
  appName: string;
  agent: BaseAgent;
  plugins?: BasePlugin[];
  artifactService?: BaseArtifactService;
  sessionService: BaseSessionService;
  memoryService?: BaseMemoryService;
  credentialService?: BaseCredentialService;
}

export class Runner {
  readonly appName: string;
  readonly agent: BaseAgent;
  readonly pluginManager: PluginManager;
  readonly artifactService?: BaseArtifactService;
  readonly sessionService: BaseSessionService;
  readonly memoryService?: BaseMemoryService;
  readonly credentialService?: BaseCredentialService;

  constructor(input: RunnerInput) {
    this.appName = input.appName;
    this.agent = input.agent;
    this.pluginManager = new PluginManager(input.plugins ?? []);
    this.artifactService = input.artifactService;
    this.sessionService = input.sessionService;
    this.memoryService = input.memoryService;
    this.credentialService = input.credentialService;
  }

  /**
   * Runs the agent and returns all generated events.
   *
   * !!NOTE: This synchronous interface is provided for local testing and
   * convenience only. For production use cases, prefer the `runAsync` method
   * which returns an async generator.
   */
  async runSync({
    userId,
    sessionId,
    newMessage,
    runConfig = new RunConfig(),
  }: {
    userId: string; sessionId: string; newMessage: Content;
    runConfig?: RunConfig;
  }): Promise<Event[]> {
    const span = trace.getTracer('gcp.vertex.agent')
                     .startSpan(`agent_run_sync [${this.agent.name}]`);
    try {
      const events: Event[] = [];
      for await (const event of this.runAsync(
          {userId, sessionId, newMessage, runConfig})) {
        events.push(event);
      }
      return events;
    } finally {
      span.end();
    }
  }

  /**
   * Runs the agent with the given message, and returns an async generator of
   * events.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param newMessage A new message to append to the session.
   * @param stateDelta An optional state delta to apply to the session.
   * @param runConfig The run config for the agent.
   * @yields The events generated by the agent.
   */
  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.
  async * runAsync({
    userId,
    sessionId,
    newMessage,
    stateDelta,
    runConfig = new RunConfig(),
  }: {
    userId: string; sessionId: string; newMessage: Content;
    stateDelta?: Record<string, any>;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, undefined> {
    // =========================================================================
    // Setup the session and invocation context
    // =========================================================================
    const span = trace.getTracer('gcp.vertex.agent').startSpan('invocation');
    try {
      const session =
          await this.sessionService.getSession({appName: this.appName, userId, sessionId});

      if (!session) {
        throw new Error(`Session not found: ${sessionId}`);
      }

      if (runConfig.supportCfc && this.agent instanceof LlmAgent) {
        const modelName = this.agent.canonicalModel.model;
        if (!modelName.startsWith('gemini-2')) {
          throw new Error(`CFC is not supported for model: ${
              modelName} in agent: ${this.agent.name}`);
        }
        // TODO - b/425992518: Add code executor support
      }

      const invocationContext = new InvocationContext({
        artifactService: this.artifactService,
        sessionService: this.sessionService,
        memoryService: this.memoryService,
        credentialService: this.credentialService,
        invocationId: newInvocationContextId(),
        agent: this.agent,
        session,
        userContent: newMessage,
        runConfig,
      });

      // =========================================================================
      // Preprocess plugins on user message
      // =========================================================================
      const pluginUserMessage =
          await this.pluginManager.runOnUserMessageCallback({
            userMessage: newMessage,
            invocationContext,
          });
      if (pluginUserMessage) {
        newMessage = pluginUserMessage as Content;
      }

      // =========================================================================
      // Append user message to session
      // =========================================================================
      if (newMessage) {
        if (!newMessage.parts?.length) {
          throw new Error('No parts in the new_message.');
        }

        // Directly saves the artifacts (if applicable) in the user message and
        // replaces the artifact data with a file name placeholder.
        // TODO - b/425992518: fix Runner<>>ArtifactService leaky abstraction.
        if (runConfig.saveInputBlobsAsArtifacts) {
          await this.saveArtifacts(
              invocationContext.invocationId, session.userId, session.id,
              newMessage);
        }
        // Append the user message to the session with optional state delta.
        await this.sessionService.appendEvent({
          session,
          event: createEvent({
            invocationId: invocationContext.invocationId,
            author: 'user',
            actions: stateDelta ? createEventActions({stateDelta}) : undefined,
            content: newMessage,
          }),
        });
      }

      // =========================================================================
      // Determine which agent should handle the workflow resumption.
      // =========================================================================
      invocationContext.agent =
          this.determineAgentForResumption(session, this.agent);

      // =========================================================================
      // Run the agent with the plugins (aka hooks to apply in the lifecycle)
      // =========================================================================
      // Step 1: Run the before_run callbacks to see if we should early exit.
      await this.pluginManager.runBeforeRunCallback({invocationContext});

      // Step 2: Otherwise continue with normal execution
      for await (
          const event of invocationContext.agent.runAsync(invocationContext)) {
        if (!event.partial) {
          await this.sessionService.appendEvent({session, event});
        }
        // Step 3: Run the on_event callbacks to optionally modify the event.
        const modifiedEvent = await this.pluginManager.runOnEventCallback(
            {invocationContext, event});
        if (modifiedEvent) {
          yield modifiedEvent;
        } else {
          yield event;
        }
      }
      // Step 4: Run the after_run callbacks to optionally modify the context.
      await this.pluginManager.runAfterRunCallback({invocationContext});
    } finally {
      span.end();
    }
  }

  /**
   * Saves artifacts from the message parts and replaces the inline data with
   * a file name placeholder.
   *
   * @param invocationId The current invocation ID.
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param message The message containing parts to process.
   */
  private async saveArtifacts(
      invocationId: string, userId: string, sessionId: string,
      message: Content): Promise<void> {
    if (!this.artifactService || !message.parts?.length) {
      return;
    }

    for (let i = 0; i < message.parts.length; i++) {
      const part = message.parts[i];
      if (!part.inlineData) {
        continue;
      }
      const fileName = `artifact_${invocationId}_${i}`;
      // TODO - b/425992518: group appname, userId, sessionId as a key.
      await this.artifactService.saveArtifact({
        appName: this.appName,
        userId,
        sessionId,
        filename: fileName,
        artifact: part,
      });
      // TODO - b/425992518: potentially buggy if accidentally exposed to LLM.
      message.parts[i] = createPartFromText(
          `Uploaded file: ${fileName}. It is saved into artifacts`);
    }
  }

  /**
   * Determines the next agent to run to continue the session. This is primarily
   * used for session resumption.
   */
  // TODO - b/425992518: This is where LRO integration should happen.
  // Needs clean up before we can generalize it.
  private determineAgentForResumption(session: Session, rootAgent: BaseAgent):
      BaseAgent {
    // =========================================================================
    // Case 1: If the last event is a function response, this returns the
    // agent that made the original function call.
    // =========================================================================
    const event = findEventByLastFunctionResponseId(session.events);
    if (event && event.author) {
      return rootAgent.findAgent(event.author) || rootAgent;
    }

    // =========================================================================
    // Case 2: Otherwise, find the last agent that emitted a message and is
    // transferable across the agent tree.
    // =========================================================================
    // TODO - b/425992518: Optimize this, not going to work for long sessions.
    // TODO - b/425992518: The behavior is dynamic, needs better documentation.
    for (let i = session.events.length - 1; i >= 0; i--) {
      console.log('event: ', JSON.stringify(session.events[i]));
      const event = session.events[i];
      if (event.author === 'user' || !event.author) {
        continue;
      }

      if (event.author === rootAgent.name) {
        return rootAgent;
      }

      const agent = rootAgent.findSubAgent(event.author!);
      if (!agent) {
        console.warn(`Event from an unknown agent: ${event.author}, event id: ${
            event.id}`);
        continue;
      }
      if (this.isRoutableLlmAgent(agent)) {
        return agent;
      }
    }
    // =========================================================================
    // Case 3: default to root agent.
    // =========================================================================
    return rootAgent;
  }

  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * An agent is transferable if:
   *  - It is an instance of `LlmAgent`.
   *  - All its ancestors are also transferable (i.e., they have
   *    `disallowTransferToParent` set to false).
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   */
  private isRoutableLlmAgent(agentToRun: BaseAgent): boolean {
    let agent: BaseAgent|undefined = agentToRun;
    while (agent) {
      if (!(agent instanceof LlmAgent)) {
        return false;
      }
      if (agent.disallowTransferToParent) {
        return false;
      }
      agent = agent.parentAgent;
    }
    return true;
  }
  // TODO - b/425992518: Implement runLive and related methods.
}

/**
 * It iterates through the events in reverse order, and returns the event
 * containing a function call with a functionCall.id matching the
 * functionResponse.id from the last event in the session.
 */
// TODO - b/425992518: a hack that used event log as transaction log. Fix.
function findEventByLastFunctionResponseId(events: Event[]): Event|null {
  if (!events.length) {
    return null;
  }

  const lastEvent = events[events.length - 1];
  const functionCallId =
      lastEvent.content?.parts?.find((part) => part.functionResponse)
          ?.functionResponse?.id;
  if (!functionCallId) {
    return null;
  }

  // TODO - b/425992518: inefficient search, fix.
  for (let i = events.length - 2; i >= 0; i--) {
    const event = events[i];
    // Looking for the system long running request euc function call.
    const functionCalls = getFunctionCalls(event);
    if (!functionCalls) {
      continue;
    }

    for (const functionCall of functionCalls) {
      if (functionCall.id === functionCallId) {
        return event;
      }
    }
  }
  return null;
}
